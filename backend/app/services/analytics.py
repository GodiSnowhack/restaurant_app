from typing import List, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, desc, extract, cast, Date

from app.models.order import Order, OrderStatus, OrderDish
from app.models.menu import Dish, Category
from app.models.reservation import Reservation
from app.models.user import User


def get_sales_by_period(
    db: Session, 
    start_date: datetime = None, 
    end_date: datetime = None
) -> List[Dict[str, Any]]:
    """
    Получение статистики продаж за период
    """
    query = db.query(
        cast(Order.created_at, Date).label('date'),
        func.count(Order.id).label('orders_count'),
        func.sum(Order.total_amount).label('total_revenue')
    )
    
    # Фильтруем только завершенные заказы
    query = query.filter(Order.status.in_([OrderStatus.COMPLETED, OrderStatus.DELIVERED]))
    
    # Применяем фильтры по датам, если указаны
    if start_date:
        query = query.filter(Order.created_at >= start_date)
    if end_date:
        query = query.filter(Order.created_at <= end_date)
    
    # Группируем по дате и сортируем
    result = query.group_by(
        cast(Order.created_at, Date)
    ).order_by(
        cast(Order.created_at, Date)
    ).all()
    
    # Форматируем результат
    return [
        {
            "date": item.date.isoformat() if hasattr(item.date, 'isoformat') else str(item.date),
            "orders_count": item.orders_count,
            "total_revenue": float(item.total_revenue) if item.total_revenue else 0
        }
        for item in result
    ]


def get_top_dishes(
    db: Session, 
    limit: int = 10,
    start_date: datetime = None,
    end_date: datetime = None
) -> List[Dict[str, Any]]:
    """
    Получение топа самых популярных блюд
    """
    query = db.query(
        Dish.id,
        Dish.name,
        Dish.price,
        func.sum(OrderDish.quantity).label("total_ordered"),
        func.sum(OrderDish.quantity * Dish.price).label("total_revenue")
    ).join(
        OrderDish, OrderDish.dish_id == Dish.id
    ).join(
        Order, Order.id == OrderDish.order_id
    )
    
    # Фильтрация только по завершенным заказам
    query = query.filter(Order.status.in_([OrderStatus.COMPLETED, OrderStatus.DELIVERED]))
    
    if start_date:
        query = query.filter(Order.created_at >= start_date)
    if end_date:
        query = query.filter(Order.created_at <= end_date)
    
    results = query.group_by(
        Dish.id
    ).order_by(
        func.sum(OrderDish.quantity).desc()
    ).limit(limit).all()
    
    return [
        {
            "id": result.id,
            "name": result.name,
            "price": result.price,
            "total_ordered": result.total_ordered,
            "total_revenue": float(result.total_revenue) if result.total_revenue else 0
        }
        for result in results
    ]


def get_revenue_by_category(
    db: Session, 
    start_date: datetime = None, 
    end_date: datetime = None
) -> List[Dict[str, Any]]:
    """
    Получение выручки по категориям
    """
    query = db.query(
        Category.id,
        Category.name,
        func.count(Dish.id).label('dishes_count'),
        func.sum(OrderDish.quantity).label('total_ordered'),
        func.sum(OrderDish.quantity * Dish.price).label('total_revenue')
    ).join(
        Dish, Dish.category_id == Category.id
    ).join(
        OrderDish, OrderDish.dish_id == Dish.id
    ).join(
        Order, Order.id == OrderDish.order_id
    )
    
    # Фильтрация только по завершенным заказам
    query = query.filter(Order.status.in_([OrderStatus.COMPLETED, OrderStatus.DELIVERED]))
    
    if start_date:
        query = query.filter(Order.created_at >= start_date)
    if end_date:
        query = query.filter(Order.created_at <= end_date)
    
    results = query.group_by(
        Category.id
    ).order_by(
        func.sum(OrderDish.quantity * Dish.price).desc()
    ).all()
    
    return [
        {
            "id": result.id,
            "name": result.name,
            "dishes_count": result.dishes_count,
            "total_ordered": result.total_ordered,
            "total_revenue": float(result.total_revenue) if result.total_revenue else 0
        }
        for result in results
    ]


def get_avg_order_value(db: Session) -> float:
    """
    Получение средней стоимости заказа
    """
    result = db.query(
        func.avg(Order.total_amount).label("avg_order_value")
    ).filter(
        Order.status.in_([OrderStatus.COMPLETED, OrderStatus.DELIVERED])
    ).first()
    
    return float(result.avg_order_value) if result.avg_order_value else 0.0


def get_table_utilization(
    db: Session, 
    start_date: datetime = None, 
    end_date: datetime = None
) -> Dict[int, int]:
    """
    Получение статистики по использованию столиков
    """
    query = db.query(
        Order.table_number,
        func.count(Order.id).label('usage_count')
    ).filter(Order.table_number.isnot(None))
    
    # Применяем фильтры по датам, если указаны
    if start_date:
        query = query.filter(Order.created_at >= start_date)
    if end_date:
        query = query.filter(Order.created_at <= end_date)
    
    # Группируем по номеру столика
    result = query.group_by(
        Order.table_number
    ).all()
    
    # Формируем словарь {table_number: usage_count}
    return {item.table_number: item.usage_count for item in result}


def get_user_stats(db: Session) -> Dict[str, Any]:
    """
    Получение статистики по пользователям
    """
    # Общее количество пользователей
    total_users = db.query(func.count(User.id)).scalar()
    
    # Активные пользователи (сделавшие хотя бы один заказ)
    active_users = db.query(
        func.count(func.distinct(Order.user_id))
    ).filter(
        Order.user_id.isnot(None)
    ).scalar()
    
    # Пользователи по ролям
    user_roles = db.query(
        User.role,
        func.count(User.id).label('count')
    ).group_by(
        User.role
    ).all()
    
    roles_count = {str(role): count for role, count in user_roles}
    
    return {
        "total_users": total_users,
        "active_users": active_users,
        "inactive_users": total_users - active_users if total_users else 0,
        "users_by_role": roles_count
    }


def get_reservation_stats(db: Session) -> Dict[str, Any]:
    """
    Получение статистики по бронированиям
    """
    today = datetime.now().date()
    tomorrow = today + timedelta(days=1)
    
    # Бронирования на сегодня
    reservations_today = db.query(
        func.count(Reservation.id)
    ).filter(
        func.date(Reservation.date) == today
    ).scalar()
    
    # Бронирования на завтра
    reservations_tomorrow = db.query(
        func.count(Reservation.id)
    ).filter(
        func.date(Reservation.date) == tomorrow
    ).scalar()
    
    # Всего активных бронирований
    active_reservations = db.query(
        func.count(Reservation.id)
    ).filter(
        func.date(Reservation.date) >= today
    ).scalar()
    
    return {
        "reservations_today": reservations_today,
        "reservations_tomorrow": reservations_tomorrow,
        "active_reservations": active_reservations
    }


def get_daily_orders(
    db: Session, 
    days: int = 30
) -> List[Dict[str, Any]]:
    """
    Получение количества заказов по дням за последние N дней
    """
    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)
    
    query = db.query(
        func.date(Order.created_at).label("date"),
        func.count(Order.id).label("orders_count"),
        func.sum(Order.total_amount).label("total_revenue")
    ).filter(
        Order.created_at >= start_date,
        Order.created_at <= end_date
    ).group_by(
        func.date(Order.created_at)
    ).order_by(
        func.date(Order.created_at)
    )
    
    results = query.all()
    
    return [
        {
            "date": result.date.isoformat() if hasattr(result.date, 'isoformat') else str(result.date),
            "orders_count": result.orders_count,
            "total_revenue": float(result.total_revenue) if result.total_revenue else 0.0
        }
        for result in results
    ] 